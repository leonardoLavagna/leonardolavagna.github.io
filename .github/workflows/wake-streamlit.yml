      - name: Wake each app (robust)
        run: |
          if [ ! -s urls.txt ]; then
            echo "::warning::No URLs to ping."
            exit 0
          fi

          while IFS= read -r url; do
            [ -z "$url" ] && continue

            # Extract host for a quick DNS sanity check
            host=$(printf "%s" "$url" | awk -F/ '{print $3}')
            if ! getent hosts "$host" >/dev/null 2>&1; then
              echo "::warning::Skipping $url â€” host not resolvable"
              continue
            fi

            echo "Waking: $url"
            # Try to wake. Follow redirects, but avoid infinite loops.
            # Log both HTTP code and the final effective URL.
            http_and_effective=$(curl -sS -L -o /dev/null \
              -w "code=%{http_code} effective=%{url_effective}" \
              -A "keepalive-bot/1.1 (+github actions)" \
              --connect-timeout 20 --max-time 120 --max-redirs 10 \
              --retry 2 --retry-delay 10 "$url")
            curl_status=$?

            echo "curl_exit=$curl_status $http_and_effective"

            # If curl itself failed (e.g., 47 = too many redirects), warn and keep going
            if [ $curl_status -ne 0 ]; then
              echo "::warning::curl failed for $url (exit $curl_status)"
              continue
            fi

            # Extract just the numeric HTTP code
            code=$(printf "%s" "$http_and_effective" | sed -n 's/.*code=\([0-9][0-9][0-9]\).*/\1/p')

            # Treat <500 as OK (cold starts can return 200/302/403 while spinning up)
            if [ -z "$code" ] || [ "$code" -ge 500 ]; then
              echo "::warning::Wake likely failed for $url (HTTP ${code:-unknown})"
            fi
          done < urls.txt

          # Never fail the whole workflow just because one app misbehaved
          exit 0
